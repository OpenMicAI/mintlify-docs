/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import * as OpenmicApi from "../../../index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as errors from "../../../../errors/index.js";

export declare namespace Bots {
    export interface Options {
        environment?: core.Supplier<environments.OpenmicApiEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token: core.Supplier<core.BearerToken>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
    }
}

export class Bots {
    protected readonly _options: Bots.Options;

    constructor(_options: Bots.Options) {
        this._options = _options;
    }

    /**
     * Retrieve all bots with optional filtering and pagination.
     *
     * @param {OpenmicApi.GetV1BotsRequest} request
     * @param {Bots.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpenmicApi.BadRequestError}
     * @throws {@link OpenmicApi.UnauthorizedError}
     * @throws {@link OpenmicApi.InternalServerError}
     *
     * @example
     *     await client.bots.listBots()
     */
    public listBots(
        request: OpenmicApi.GetV1BotsRequest = {},
        requestOptions?: Bots.RequestOptions,
    ): core.HttpResponsePromise<OpenmicApi.ListBotsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listBots(request, requestOptions));
    }

    private async __listBots(
        request: OpenmicApi.GetV1BotsRequest = {},
        requestOptions?: Bots.RequestOptions,
    ): Promise<core.WithRawResponse<OpenmicApi.ListBotsResponse>> {
        const { limit, offset, name, created_after: createdAfter, created_before: createdBefore } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (offset != null) {
            _queryParams["offset"] = offset.toString();
        }

        if (name != null) {
            _queryParams["name"] = name;
        }

        if (createdAfter != null) {
            _queryParams["created_after"] = createdAfter;
        }

        if (createdBefore != null) {
            _queryParams["created_before"] = createdBefore;
        }

        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpenmicApiEnvironment.Default,
                "v1/bots",
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            queryParameters: _queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as OpenmicApi.ListBotsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpenmicApi.BadRequestError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 401:
                    throw new OpenmicApi.UnauthorizedError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 500:
                    throw new OpenmicApi.InternalServerError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.OpenmicApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.OpenmicApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.OpenmicApiTimeoutError("Timeout exceeded when calling GET /v1/bots.");
            case "unknown":
                throw new errors.OpenmicApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new bot with specified configuration.
     *
     * @param {OpenmicApi.CreateBotRequest} request
     * @param {Bots.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpenmicApi.BadRequestError}
     * @throws {@link OpenmicApi.UnauthorizedError}
     * @throws {@link OpenmicApi.InternalServerError}
     *
     * @example
     *     await client.bots.createBot({
     *         name: "Customer Support Bot",
     *         prompt: "You are a helpful customer support assistant. Be polite, professional, and always try to resolve customer issues.",
     *         first_message: "Hello! I'm here to help you with any questions or concerns you may have. How can I assist you today?",
     *         knowledge_base_id: 123,
     *         voice_provider: "OpenAI",
     *         voice: "alloy",
     *         voice_model: "tts-1",
     *         voice_speed: 1,
     *         llm_model_name: "gpt-4",
     *         llm_model_temperature: 0.7,
     *         stt_provider: "Deepgram",
     *         stt_model: "nova-2",
     *         call_settings: {
     *             max_call_duration: 10,
     *             silence_timeout: 15,
     *             silence_timeout_max_retries: 3,
     *             silence_timeout_message: "I didn't hear anything. Are you still there?",
     *             call_recording_enabled: true,
     *             voicemail_detection_enabled: true,
     *             hipaa_compliance_enabled: false,
     *             pci_compliance_enabled: false
     *         },
     *         advanced_settings: {
     *             agent_personality: "friendly",
     *             humanize_conversation: true,
     *             background_noise_reduction: true,
     *             allow_interruptions: true,
     *             min_interruption_duration: 0.5,
     *             agent_response_length: "normal",
     *             short_pause: 0.3,
     *             long_pause: 1
     *         },
     *         post_call_settings: {
     *             summary_prompt: "Provide a brief summary of the customer interaction and any action items.",
     *             success_evaluation_prompt: "Rate the success of this call on a scale of 1-10 based on customer satisfaction.",
     *             success_evaluation_rubric_type: "NUMERIC_SCALE"
     *         }
     *     })
     */
    public createBot(
        request: OpenmicApi.CreateBotRequest,
        requestOptions?: Bots.RequestOptions,
    ): core.HttpResponsePromise<OpenmicApi.BotResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createBot(request, requestOptions));
    }

    private async __createBot(
        request: OpenmicApi.CreateBotRequest,
        requestOptions?: Bots.RequestOptions,
    ): Promise<core.WithRawResponse<OpenmicApi.BotResponse>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpenmicApiEnvironment.Default,
                "v1/bots",
            ),
            method: "POST",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as OpenmicApi.BotResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpenmicApi.BadRequestError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 401:
                    throw new OpenmicApi.UnauthorizedError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 500:
                    throw new OpenmicApi.InternalServerError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.OpenmicApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.OpenmicApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.OpenmicApiTimeoutError("Timeout exceeded when calling POST /v1/bots.");
            case "unknown":
                throw new errors.OpenmicApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve details of a specific bot by its UID.
     *
     * @param {string} uid - The unique identifier of the bot
     * @param {Bots.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpenmicApi.BadRequestError}
     * @throws {@link OpenmicApi.UnauthorizedError}
     * @throws {@link OpenmicApi.NotFoundError}
     * @throws {@link OpenmicApi.InternalServerError}
     *
     * @example
     *     await client.bots.getBot("uid")
     */
    public getBot(uid: string, requestOptions?: Bots.RequestOptions): core.HttpResponsePromise<OpenmicApi.BotResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getBot(uid, requestOptions));
    }

    private async __getBot(
        uid: string,
        requestOptions?: Bots.RequestOptions,
    ): Promise<core.WithRawResponse<OpenmicApi.BotResponse>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpenmicApiEnvironment.Default,
                `v1/bots/${encodeURIComponent(uid)}`,
            ),
            method: "GET",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as OpenmicApi.BotResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpenmicApi.BadRequestError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 401:
                    throw new OpenmicApi.UnauthorizedError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new OpenmicApi.NotFoundError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 500:
                    throw new OpenmicApi.InternalServerError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.OpenmicApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.OpenmicApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.OpenmicApiTimeoutError("Timeout exceeded when calling GET /v1/bots/{uid}.");
            case "unknown":
                throw new errors.OpenmicApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete a bot by its UID.
     *
     * @param {string} uid - The unique identifier of the bot
     * @param {Bots.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpenmicApi.BadRequestError}
     * @throws {@link OpenmicApi.UnauthorizedError}
     * @throws {@link OpenmicApi.NotFoundError}
     * @throws {@link OpenmicApi.ConflictError}
     * @throws {@link OpenmicApi.InternalServerError}
     *
     * @example
     *     await client.bots.deleteBot("uid")
     */
    public deleteBot(uid: string, requestOptions?: Bots.RequestOptions): core.HttpResponsePromise<void> {
        return core.HttpResponsePromise.fromPromise(this.__deleteBot(uid, requestOptions));
    }

    private async __deleteBot(uid: string, requestOptions?: Bots.RequestOptions): Promise<core.WithRawResponse<void>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpenmicApiEnvironment.Default,
                `v1/bots/${encodeURIComponent(uid)}`,
            ),
            method: "DELETE",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: undefined, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpenmicApi.BadRequestError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 401:
                    throw new OpenmicApi.UnauthorizedError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new OpenmicApi.NotFoundError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 409:
                    throw new OpenmicApi.ConflictError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 500:
                    throw new OpenmicApi.InternalServerError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.OpenmicApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.OpenmicApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.OpenmicApiTimeoutError("Timeout exceeded when calling DELETE /v1/bots/{uid}.");
            case "unknown":
                throw new errors.OpenmicApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update an existing bot's configuration.
     *
     * @param {string} uid - The unique identifier of the bot
     * @param {OpenmicApi.UpdateBotRequest} request
     * @param {Bots.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpenmicApi.BadRequestError}
     * @throws {@link OpenmicApi.UnauthorizedError}
     * @throws {@link OpenmicApi.NotFoundError}
     * @throws {@link OpenmicApi.InternalServerError}
     *
     * @example
     *     await client.bots.updateBot("uid", {
     *         name: "Updated Customer Support Bot",
     *         prompt: "You are an advanced customer support assistant with expertise in technical issues.",
     *         voice_speed: 1.1,
     *         llm_model_temperature: 0.8,
     *         call_settings: {
     *             max_call_duration: 15,
     *             silence_timeout: 20
     *         }
     *     })
     */
    public updateBot(
        uid: string,
        request: OpenmicApi.UpdateBotRequest,
        requestOptions?: Bots.RequestOptions,
    ): core.HttpResponsePromise<OpenmicApi.BotResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateBot(uid, request, requestOptions));
    }

    private async __updateBot(
        uid: string,
        request: OpenmicApi.UpdateBotRequest,
        requestOptions?: Bots.RequestOptions,
    ): Promise<core.WithRawResponse<OpenmicApi.BotResponse>> {
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.OpenmicApiEnvironment.Default,
                `v1/bots/${encodeURIComponent(uid)}`,
            ),
            method: "PATCH",
            headers: mergeHeaders(
                this._options?.headers,
                mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
                requestOptions?.headers,
            ),
            contentType: "application/json",
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as OpenmicApi.BotResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new OpenmicApi.BadRequestError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 401:
                    throw new OpenmicApi.UnauthorizedError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 404:
                    throw new OpenmicApi.NotFoundError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                case 500:
                    throw new OpenmicApi.InternalServerError(
                        _response.error.body as OpenmicApi.Error_,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.OpenmicApiError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.OpenmicApiError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.OpenmicApiTimeoutError("Timeout exceeded when calling PATCH /v1/bots/{uid}.");
            case "unknown":
                throw new errors.OpenmicApiError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
